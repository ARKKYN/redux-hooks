{"version":3,"sources":["Provider.tsx","utils.ts","index.ts"],"names":[],"mappings":";;;AAGA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,QAAA,YAAA,EAHA,IAAA,EAAA,EAAA,QAAA,UAGA,SAAA,EAAmC,GAAE,IAAA,EAAA,EAAA,SAC5B,OAAA,SAAC,GAAE,IAAA,EAAA,EAAA,MAAO,EAAA,EAAA,SAAe,OAAA,EAAA,QAAA,cAAC,EAAQ,CAAC,MAAO,GAAQ,IAD3D,QAAA,QAAA;;ACKA,aAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GARA,SAAS,EAAG,EAAQ,GACd,OAAA,IAAM,EACK,IAAN,GAAiB,IAAN,GAAW,EAAI,GAAM,EAAI,EAEpC,GAAM,GAAK,GAAM,EAI5B,SAAgB,EAAa,EAAW,GAClC,GAAA,EAAG,EAAM,GACJ,OAAA,EAIP,GAAgB,WAAhB,EAAO,IACE,OAAT,GACgB,WAAhB,EAAO,IACE,OAAT,EAEO,OAAA,EAGH,IAAA,EAAQ,OAAO,KAAK,GACpB,EAAQ,OAAO,KAAK,GAEtB,GAAA,EAAM,SAAW,EAAM,OAClB,OAAA,EAGJ,IAAA,IAAI,EAAI,EAAG,EAAI,EAAM,OAAQ,IAE9B,IAAC,OAAO,UAAU,eAAe,KAAK,EAAM,EAAM,MACjD,EAAG,EAAK,EAAM,IAAK,EAAK,EAAM,KAExB,OAAA,EAIJ,OAAA,EA9BT,QAAA,YAAA,EAAA,QAAA,aAAA;;AC0GA,aAAA,IAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,QAAA,YAAA,EAlHA,IA+BI,EA/BJ,EAAA,QAAA,SASA,EAAA,QAAA,SAQA,EAAA,EAAA,QAAA,eACA,EAAA,QAAA,WAwBA,SAAgB,EACd,GAEO,MAAyB,mBAAlB,EAZH,QAAA,mBAAqB,WAChC,EAAU,EAAA,cAAgC,MACpC,IAAA,EAAW,EAAA,QAAkB,GAC5B,MAAA,CACL,QAAO,EACP,SAAQ,IAIZ,QAAA,sBAAA,EAMA,IAAM,EAAW,SAMf,EACA,EAGA,GAGM,IAAA,EAAa,EAAA,WAAW,GAE1B,IAAC,EACG,MAAA,IAAI,MAAM,mDAEV,IAAA,EAAA,EAAA,SAAU,EAAA,EAAA,SAAU,EAAA,EAAA,UACtB,EAAQ,IAIR,EAA0B,EAAA,YAAY,EAAiB,IACvD,EAA6B,EAAA,YACjC,EAAsB,GAClB,WAAM,OAAA,EAAA,mBAAmB,EAAoB,IAC7C,EACJ,IAGI,EAAc,EAAA,OAAO,EAAwB,EAAO,IACpD,EAAsB,EAAA,OAC1B,EAA2B,EAAU,IAG9B,EAAH,EAAA,SAAA,EAAA,SAAG,GAwBT,OAlBA,EAAA,UAAU,WACF,IAAA,EAAc,EAAU,WACtB,IAAA,EAAmB,EAAwB,KAM5C,EAAA,aAAa,EAAkB,EAAY,WAC9C,EAAY,QAAU,EACtB,EAAe,MAGZ,OAAA,WACL,MAED,CAAC,IAEJ,EAAA,GACK,EAAY,QACZ,EAAoB,UAI3B,QAAA,QAAe","file":"index.js","sourceRoot":"../src","sourcesContent":["import React, { Context } from \"react\";\nimport { Store } from \"redux\";\n\nexport default function<RootState>({ Provider }: Context<Store<RootState>>) {\n  return ({ store, children }) => <Provider value={store}>{children}</Provider>;\n}\n","function is(x: any, y: any) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nexport function shallowEqual(objA: any, objB: any) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== \"object\" ||\n    objA === null ||\n    typeof objB !== \"object\" ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  useEffect,\n  useContext,\n  useState,\n  createContext,\n  Context,\n  useCallback,\n  useRef\n} from \"react\";\nimport {\n  Dispatch,\n  Action,\n  Store,\n  ActionCreatorsMapObject,\n  bindActionCreators\n} from \"redux\";\n\nimport ProviderComponent from \"./Provider\";\nimport { shallowEqual } from \"./utils\";\nimport { Promise } from \"q\";\n\nexport type MapStateToProps<State, TStateProps, TOwnProps> = (\n  state: State,\n  ownProps?: TOwnProps\n) => TStateProps;\n\nexport type MapDispatchToProps<TDispatchProps, TOwnProps> = (\n  dispatch: Dispatch<Action>,\n  ownProps?: TOwnProps\n) => TDispatchProps;\n\nlet context: Context<Store>;\n\nexport const createStoreContext = <RootState>() => {\n  context = createContext<Store<RootState>>(null as any);\n  const Provider = ProviderComponent(context);\n  return {\n    context,\n    Provider\n  };\n};\n\nexport function areDispatchActionsMap<TDispatchProps, TOwnProps>(\n  dispatchProps: MapDispatchToProps<TDispatchProps, TOwnProps> | TDispatchProps\n): dispatchProps is TDispatchProps {\n  return typeof dispatchProps !== \"function\";\n}\n\nconst useRedux = <\n  State = {},\n  TStateProps = {},\n  TDispatchProps extends ActionCreatorsMapObject<any> = {},\n  TOwnProps = {}\n>(\n  mapStateToProps: MapStateToProps<State, TStateProps, TOwnProps>,\n  mapDispatchToProps:\n    | MapDispatchToProps<TDispatchProps, TOwnProps>\n    | TDispatchProps,\n  ownProps?: TOwnProps\n) => {\n  /* Getting the reference of the store from the passed in context in the <Provider/> */\n  const store = <any>useContext(context);\n  /* If store is not supplied in the <Provider/>, then throw a Missing Store error */\n  if (!store) {\n    throw new Error(\"Store has not been provided in the <Provider />\");\n  }\n  const { getState, dispatch, subscribe } = store;\n  const state = getState();\n  /* Creating memoized Callbacks for mapStateToProps and mapDispatchToProps to prevent\n   *  multiple copies of them being created on every render\n   */\n  const memoizedMapStateToProps = useCallback(mapStateToProps, []);\n  const memoizedMapDispatchToProps = useCallback(\n    areDispatchActionsMap(mapDispatchToProps)\n      ? () => bindActionCreators(mapDispatchToProps, dispatch)\n      : mapDispatchToProps,\n    []\n  );\n  /** Maintaining a reference of the mappedState across re-renders */\n  const mappedState = useRef(memoizedMapStateToProps(state, ownProps));\n  const mappedDispatchProps = useRef(\n    memoizedMapDispatchToProps(dispatch, ownProps)\n  );\n  /* A way to trigger render on mappedState change */\n  const [, setMappedState] = useState(mappedState.current);\n  /**\n   * Subscribing the store only once the component where useRedux is being used is mounted.\n   * UnSubscribing & Subscribing again in case the store is changed in the context.\n   * Returning cleanup handler in order to unsubscribe from the subscription in case of unmount\n   */\n  useEffect(() => {\n    const unsubscribe = subscribe(() => {\n      const nextDerivedState = memoizedMapStateToProps(getState());\n      /**\n       * Checking whether the new derived/mapped state is not in sync with the previously mapped state\n       * and only then updating the UI by calling setMappedState while updating our reference to the\n       * current mappedState.\n       */\n      if (!shallowEqual(nextDerivedState, mappedState.current)) {\n        mappedState.current = nextDerivedState;\n        setMappedState(nextDerivedState);\n      }\n    });\n    return () => {\n      unsubscribe();\n    };\n  }, [store]);\n  /* Returning both the mappedStateProps and mappedDispatchProps in the end */\n  return {\n    ...mappedState.current,\n    ...mappedDispatchProps.current\n  };\n};\n\nexport default useRedux;\n"]}